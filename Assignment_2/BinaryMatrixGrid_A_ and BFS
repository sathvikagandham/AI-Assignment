import heapq
import math

# 8 possible moves (horizontal, vertical, diagonal)
directions = [(-1, -1), (-1, 0), (-1, 1),
              (0, -1),          (0, 1),
              (1, -1),  (1, 0), (1, 1)]

def heuristic(a, b, type="manhattan"):
    """Heuristic function: Manhattan or Euclidean"""
    (x1, y1), (x2, y2) = a, b
    if type == "manhattan":
        return abs(x1 - x2) + abs(y1 - y2)
    else:  # Euclidean
        return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)


# -------------------- Best First Search --------------------
def best_first_search(grid, heuristic_type="manhattan"):
    n = len(grid)
    start, goal = (0, 0), (n - 1, n - 1)

    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:
        return -1, []

    pq = [(heuristic(start, goal, heuristic_type), start)]
    visited = set()
    parent = {start: None}

    while pq:
        _, current = heapq.heappop(pq)
        if current in visited:
            continue
        visited.add(current)

        if current == goal:
            # reconstruct path
            path = []
            while current:
                path.append(current)
                current = parent[current]
            return len(path), path[::-1]

        x, y = current
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0:
                if (nx, ny) not in visited:
                    parent[(nx, ny)] = current
                    heapq.heappush(pq, (heuristic((nx, ny), goal, heuristic_type), (nx, ny)))

    return -1, []


# -------------------- A* Search --------------------
def a_star_search(grid, heuristic_type="manhattan"):
    n = len(grid)
    start, goal = (0, 0), (n - 1, n - 1)

    if grid[0][0] == 1 or grid[n - 1][n - 1] == 1:
        return -1, []

    pq = [(heuristic(start, goal, heuristic_type), 0, start)]
    g_cost = {start: 0}
    parent = {start: None}

    while pq:
        f, g, current = heapq.heappop(pq)
        if current == goal:
            # reconstruct path
            path = []
            while current:
                path.append(current)
                current = parent[current]
            return len(path), path[::-1]

        x, y = current
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0:
                new_g = g + 1
                if (nx, ny) not in g_cost or new_g < g_cost[(nx, ny)]:
                    g_cost[(nx, ny)] = new_g
                    f = new_g + heuristic((nx, ny), goal, heuristic_type)
                    parent[(nx, ny)] = current
                    heapq.heappush(pq, (f, new_g, (nx, ny)))

    return -1, []


# -------------------- Driver Code with Examples --------------------
if __name__ == "__main__":
    test_cases = [
        [[0, 1],
         [1, 0]],

        [[0, 0, 0],
         [1, 1, 0],
         [1, 1, 0]],

        [[1, 0, 0],
         [1, 1, 0],
         [1, 1, 0]]
    ]

    for idx, grid in enumerate(test_cases, 1):
        print(f"\nExample {idx}:")
        bfs_len, bfs_path = best_first_search(grid)
        print(f"Best First Search  → Path length: {bfs_len}, Path: {bfs_path}")
        astar_len, astar_path = a_star_search(grid)
        print(f"A* Search          → Path length: {astar_len}, Path: {astar_path}")
